// Generated by CoffeeScript 1.6.3
(function() {
  var Chess,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Chess = Chess = (function() {
    var AIPlayer, Bishop, Board, Game, HoppingPiece, HumanPlayer, King, Knight, LosingChess, Pawn, Piece, Player, Queen, RandomPlayer, Rook, RuleBook, SlidingPiece, Standard, _ref, _ref1, _ref2, _ref3;

    function Chess() {}

    Chess.Board = Board = (function() {
      function Board(emptyBoard) {
        var b, pieces, set, start, w, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1;
        b = "black";
        w = "white";
        this.boardObject = {};
        for (x = _i = 1; _i <= 8; x = ++_i) {
          this.boardObject[x] = {};
        }
        this.kings = {};
        if (!emptyBoard) {
          _ref = [[1, b], [8, w]];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            set = _ref[_j];
            start = [[[[1, set[0]], [8, set[0]]], Rook, set[1]], [[[2, set[0]], [7, set[0]]], Knight, set[1]], [[[3, set[0]], [6, set[0]]], Bishop, set[1]], [[[4, set[0]]], Queen, set[1]], [[[5, set[0]]], King, set[1]]];
            for (_k = 0, _len1 = start.length; _k < _len1; _k++) {
              pieces = start[_k];
              this.place.apply(this, pieces);
            }
          }
          _ref1 = [[2, b], [7, w]];
          for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
            set = _ref1[_l];
            for (x = _m = 1; _m <= 8; x = ++_m) {
              this.place([[x, set[0]]], Pawn, set[1]);
            }
          }
        }
      }

      Board.prototype.boardDup = function() {
        var duppedBoard, newPieceColor, newPiecePosition, newpieceConstructor, piece, _i, _len, _ref;
        duppedBoard = new Board({});
        _ref = this.pieces(true);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          piece = _ref[_i];
          newPiecePosition = piece.positon;
          newpieceConstructor = piece.__proto__.constructor;
          newPieceColor = piece.color;
          duppedBoard.place([piece.position], newpieceConstructor, newPieceColor);
        }
        return duppedBoard;
      };

      Board.prototype.place = function(positions, piece, color) {
        var coord, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = positions.length; _i < _len; _i++) {
          coord = positions[_i];
          _results.push(this.boardObject[coord[0]][coord[1]] = new piece(coord, this, color));
        }
        return _results;
      };

      Board.prototype.pieces = function(array) {
        var output, piece, x, y, _i, _j, _k, _l;
        if (array) {
          output = [];
          for (x = _i = 1; _i <= 8; x = ++_i) {
            for (y = _j = 1; _j <= 8; y = ++_j) {
              piece = this.pos([x, y]);
              if (piece) {
                output.push(piece);
              }
            }
          }
        } else {
          output = {
            "black": [],
            "white": []
          };
          for (x = _k = 1; _k <= 8; x = ++_k) {
            for (y = _l = 1; _l <= 8; y = ++_l) {
              piece = this.pos([x, y]);
              if (piece) {
                if (piece.color === "white") {
                  output.white.push(piece);
                } else {
                  output.black.push(piece);
                }
              }
            }
          }
        }
        return output;
      };

      Board.prototype.remove = function(position) {
        return this.boardObject[position[0]][position[1]] = void 0;
      };

      Board.prototype.pos = function(xy) {
        if (this.onBoard(xy)) {
          return this.boardObject[xy[0]][xy[1]];
        } else {
          return void 0;
        }
      };

      Board.prototype.onBoard = function(xy) {
        var _ref, _ref1;
        return (_ref = parseInt(xy[0]), __indexOf.call([1, 2, 3, 4, 5, 6, 7, 8], _ref) >= 0) && (_ref1 = parseInt(xy[1]), __indexOf.call([1, 2, 3, 4, 5, 6, 7, 8], _ref1) >= 0);
      };

      Board.prototype.forceMove = function(startPosition, endPosition) {
        var piece;
        piece = this.pos(startPosition);
        return piece.forceMove(endPosition);
      };

      return Board;

    })();

    Chess.Piece = Piece = (function() {
      function Piece(position, board, color, options) {
        var d, _i, _j, _len, _len1, _ref, _ref1;
        this.position = position;
        this.board = board;
        this.color = color;
        this.deltas = [];
        if (options && options.diag) {
          _ref = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            d = _ref[_i];
            this.deltas.push(d);
          }
        }
        if (options && options.horiz) {
          _ref1 = [[1, 0], [-1, 0], [0, 1], [0, -1]];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            d = _ref1[_j];
            this.deltas.push(d);
          }
        }
      }

      Piece.prototype.forceMove = function(position) {
        var old;
        old = this.position;
        this.position = [parseInt(position[0]), parseInt(position[1])];
        this.board.remove(old);
        return this.board.boardObject[position[0]][position[1]] = this;
      };

      Piece.prototype.enemy = function(coord) {
        return this.board.pos(coord) && this.board.pos(coord).color !== this.color;
      };

      Piece.prototype.friend = function(coord) {
        return this.board.pos(coord) && this.board.pos(coord).color === this.color;
      };

      Piece.prototype.cssSelector = function() {
        return "\\3" + this.position[0].toString() + " \\," + this.position[1].toString();
      };

      return Piece;

    })();

    Chess.SlidingPiece = SlidingPiece = (function(_super) {
      __extends(SlidingPiece, _super);

      function SlidingPiece() {
        _ref = SlidingPiece.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      SlidingPiece.prototype.validMoves = function() {
        var current, delta, finished, offset, output, _i, _len, _ref1;
        output = [];
        _ref1 = this.deltas;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          delta = _ref1[_i];
          finished = false;
          offset = 1;
          while (!finished) {
            current = [this.position[0] + delta[0] * offset, this.position[1] + delta[1] * offset];
            if (this.enemy(current)) {
              finished = true;
            }
            if (this.friend(current) || !this.board.onBoard(current)) {
              finished = true;
              break;
            }
            output.push(current);
            offset++;
          }
        }
        return output;
      };

      return SlidingPiece;

    })(Piece);

    Chess.HoppingPiece = HoppingPiece = (function(_super) {
      __extends(HoppingPiece, _super);

      function HoppingPiece() {
        _ref1 = HoppingPiece.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      HoppingPiece.prototype.validMoves = function() {
        var current, delta, output, _i, _len, _ref2;
        output = [];
        _ref2 = this.deltas;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          delta = _ref2[_i];
          current = [this.position[0] + delta[0], this.position[1] + delta[1]];
          if (!(this.friend(current) || !this.board.onBoard(current))) {
            output.push(current);
          }
        }
        return output;
      };

      return HoppingPiece;

    })(Piece);

    Chess.Rook = Rook = (function(_super) {
      __extends(Rook, _super);

      function Rook(position, board, color) {
        Rook.__super__.constructor.call(this, position, board, color, {
          horiz: true
        });
        this.string = color[0] + "R";
        this.value = 5;
      }

      return Rook;

    })(SlidingPiece);

    Chess.Knight = Knight = (function(_super) {
      __extends(Knight, _super);

      function Knight(position, board, color) {
        Knight.__super__.constructor.call(this, position, board, color);
        this.deltas = [[2, 1], [1, 2], [-2, 1], [1, -2], [2, -1], [-1, 2], [-2, -1], [-1, -2]];
        this.string = color[0] + "N";
        this.value = 3;
      }

      return Knight;

    })(HoppingPiece);

    Chess.King = King = (function(_super) {
      __extends(King, _super);

      function King(position, board, color) {
        King.__super__.constructor.call(this, position, board, color, {
          diag: true,
          horiz: true
        });
        board.kings[color] = this;
        this.string = color[0] + "K";
        this.value = 1000;
      }

      return King;

    })(HoppingPiece);

    Chess.Pawn = Pawn = (function(_super) {
      __extends(Pawn, _super);

      function Pawn(position, board, color) {
        Pawn.__super__.constructor.call(this, position, board, color);
        if (color === "white") {
          this.y = -1;
        } else {
          this.y = 1;
        }
        this.move = [0, this.y];
        this.captures = [[1, this.y], [-1, this.y]];
        this.string = color[0] + "P";
        this.value = 1;
      }

      Pawn.prototype.validMoves = function() {
        var capture, coord, move, output, _i, _len, _ref2;
        output = [];
        move = [this.position[0] + this.move[0], this.position[1] + this.move[1]];
        if (!this.board.pos(move) && this.board.onBoard(move)) {
          output.push(move);
          if (((move[1] === 6 && this.color === 'white') || (move[1] === 3 && this.color === 'black')) && !this.board.pos([move[0], move[1] + this.y])) {
            output.push([move[0], move[1] + this.y]);
          }
        }
        _ref2 = this.captures;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          coord = _ref2[_i];
          capture = [coord[0] + this.position[0], coord[1] + this.position[1]];
          if (this.enemy(capture)) {
            output.push(capture);
          }
        }
        return output;
      };

      return Pawn;

    })(HoppingPiece);

    Chess.Bishop = Bishop = (function(_super) {
      __extends(Bishop, _super);

      function Bishop(position, board, color) {
        Bishop.__super__.constructor.call(this, position, board, color, {
          diag: true
        });
        this.string = color[0] + "B";
        this.value = 3;
      }

      return Bishop;

    })(SlidingPiece);

    Chess.Queen = Queen = (function(_super) {
      __extends(Queen, _super);

      function Queen(position, board, color) {
        Queen.__super__.constructor.call(this, position, board, color, {
          diag: true,
          horiz: true
        });
        this.string = color[0] + "Q";
        this.value = 9;
      }

      return Queen;

    })(SlidingPiece);

    Chess.RuleBook = RuleBook = (function() {
      function RuleBook() {
        this.board = new Board;
      }

      RuleBook.prototype.playerCaptureMoves = function(color, withStartingCoord, board) {
        var output, piece, pieceCaptures, _i, _len, _ref2;
        board || (board = this.board);
        output = [];
        _ref2 = board.pieces()[color];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          piece = _ref2[_i];
          pieceCaptures = this.pieceCaptureMoves(piece, board);
          if (pieceCaptures.length) {
            if (withStartingCoord) {
              output.push([piece.position, pieceCaptures]);
            } else {
              output.push.apply(output, pieceCaptures);
            }
          }
        }
        return output;
      };

      RuleBook.prototype.pieceCaptureMoves = function(piece, board) {
        var move, output, _i, _len, _ref2;
        board || (board = this.board);
        output = [];
        _ref2 = piece.validMoves();
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          move = _ref2[_i];
          if (board.pos(move) && board.pos(move).color !== piece.color) {
            output.push(move);
          }
        }
        return output;
      };

      return RuleBook;

    })();

    Chess.Standard = Standard = (function(_super) {
      __extends(Standard, _super);

      function Standard() {
        _ref2 = Standard.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      Standard.prototype.inCheck = function(color, board) {
        var captureMovesString, opponent, _ref3;
        board || (board = this.board);
        opponent = this.opponent(color);
        captureMovesString = this.playerCaptureMoves(opponent, null, board).map(function(coord) {
          return coord.toString();
        });
        if (_ref3 = board.kings[color].position.toString(), __indexOf.call(captureMovesString, _ref3) >= 0) {
          return true;
        }
        return false;
      };

      Standard.prototype.opponent = function(color) {
        if (color === "white") {
          return "black";
        }
        if (color === "black") {
          return "white";
        }
      };

      Standard.prototype.playerValidMoves = function(color, withStartingCoord, board) {
        var endPos, output, piece, suboutput, tempBoard, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref3, _ref4, _ref5, _ref6;
        board || (board = this.board);
        output = [];
        if (withStartingCoord) {
          _ref3 = board.pieces()[color];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            piece = _ref3[_i];
            if (piece.validMoves().length) {
              _ref4 = piece.validMoves();
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                endPos = _ref4[_j];
                tempBoard = board.boardDup();
                tempBoard.forceMove(piece.position, endPos);
                if (!this.inCheck(color, tempBoard)) {
                  output.push([piece.position, endPos]);
                }
              }
            }
          }
        } else {
          _ref5 = board.pieces()[color];
          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
            piece = _ref5[_k];
            if (piece.validMoves().length) {
              suboutput = [];
              _ref6 = piece.validMoves();
              for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
                endPos = _ref6[_l];
                tempBoard = board.boardDup();
                tempBoard.forceMove(piece.position, endPos);
                if (!this.inCheck(color, tempBoard)) {
                  suboutput.push(endPos);
                }
              }
              if (suboutput.length) {
                output.push([piece.position, suboutput]);
              }
            }
          }
        }
        return output;
      };

      Standard.prototype.inCheckMate = function(color) {
        var move, opponent, piece, tempBoard, _i, _len, _ref3;
        opponent = this.opponent(color);
        if (!this.inCheck(color)) {
          return false;
        }
        _ref3 = this.playerValidMoves(color, true);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          move = _ref3[_i];
          tempBoard = this.board.boardDup();
          piece = tempBoard.pos(move[0]);
          piece.forceMove(move[1]);
          if (!this.inCheck(color, tempBoard)) {
            return false;
          }
        }
        return true;
      };

      Standard.prototype.availableMoves = function(piece, board) {
        var move, newPiece, output, tempBoard, _i, _len, _ref3;
        board || (board = this.board);
        output = [];
        _ref3 = piece.validMoves();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          move = _ref3[_i];
          tempBoard = board.boardDup();
          newPiece = tempBoard.pos(piece.position);
          newPiece.forceMove(move);
          if (!this.inCheck(piece.color, tempBoard.board)) {
            output.push(move);
          }
        }
        return output;
      };

      Standard.prototype.playerWon = function() {
        if (this.inCheckMate('white')) {
          return "black";
        } else if (this.inCheckMate('black')) {
          return "white";
        } else {
          return null;
        }
      };

      return Standard;

    })(RuleBook);

    Chess.LosingChess = LosingChess = (function(_super) {
      __extends(LosingChess, _super);

      function LosingChess() {
        _ref3 = LosingChess.__super__.constructor.apply(this, arguments);
        return _ref3;
      }

      LosingChess.prototype.playerValidMoves = function(color, withStartingCoord) {
        var endPos, output, piece, _i, _j, _k, _len, _len1, _len2, _ref4, _ref5, _ref6;
        output = [];
        if (this.playerCaptureMoves(color).length) {
          return this.playerCaptureMoves(color, withStartingCoord);
        }
        if (withStartingCoord) {
          _ref4 = this.board.pieces()[color];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            piece = _ref4[_i];
            if (piece.validMoves().length) {
              _ref5 = piece.validMoves();
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                endPos = _ref5[_j];
                output.push([piece.position, endPos]);
              }
            }
          }
        } else {
          _ref6 = this.board.pieces()[color];
          for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
            piece = _ref6[_k];
            output.push.apply(output, piece.validMoves());
          }
        }
        return output;
      };

      LosingChess.prototype.availableMoves = function(piece) {
        if (this.playerCaptureMoves(piece.color).length) {
          return this.pieceCaptureMoves(piece);
        } else {
          return piece.validMoves();
        }
      };

      LosingChess.prototype.playerWon = function() {
        if (this.board.pieces().white.length === 0) {
          return 'white';
        } else if (this.board.pieces().black.length === 0) {
          return 'black';
        } else {
          return null;
        }
      };

      return LosingChess;

    })(RuleBook);

    Chess.Player = Player = (function() {
      function Player(color, ruleBook) {
        this.color = color;
        this.ruleBook = ruleBook;
      }

      return Player;

    })();

    Chess.HumanPlayer = HumanPlayer = (function(_super) {
      __extends(HumanPlayer, _super);

      function HumanPlayer(color, ruleBook) {
        this.type = "human";
        HumanPlayer.__super__.constructor.call(this, color, ruleBook);
      }

      return HumanPlayer;

    })(Player);

    Chess.RandomPlayer = RandomPlayer = (function(_super) {
      __extends(RandomPlayer, _super);

      function RandomPlayer(color, ruleBook) {
        this.type = "computer";
        RandomPlayer.__super__.constructor.call(this, color, ruleBook);
      }

      RandomPlayer.prototype.moveChoice = function() {
        var pieceToMove, possibleMoves;
        possibleMoves = this.ruleBook.playerValidMoves(this.color, true);
        pieceToMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        return pieceToMove;
      };

      return RandomPlayer;

    })(Player);

    Chess.StandardAIPlayer = AIPlayer = (function(_super) {
      __extends(AIPlayer, _super);

      function AIPlayer(color, ruleBook, level) {
        this.type = "computer";
        this.level = level || 1;
        AIPlayer.__super__.constructor.call(this, color, ruleBook);
      }

      AIPlayer.prototype.scoreBoard = function(color, board) {
        return this.valueOfBoardBalance(color, board);
      };

      AIPlayer.prototype.valueOfBoardBalance = function(color, board) {
        var opponent;
        opponent = this.ruleBook.opponent(color);
        if (this.ruleBook.inCheckMate(color)) {
          return -100000;
        }
        if (this.ruleBook.inCheckMate(opponent)) {
          return 100000;
        }
        return board.pieces()[color].reduce(function(accum, piece) {
          return accum + piece.value;
        }, 0 - board.pieces()[opponent].reduce(function(accum, piece) {
          return accum + piece.value;
        }, 0));
      };

      AIPlayer.prototype.valueOfUnprotectedAndThreatened = function(color, board) {
        var assaultingPiece, assualtingPieceClone, defendingPiece, opponent, output, tempBoard, _i, _j, _len, _len1, _ref4, _ref5, _ref6, _ref7;
        opponent = this.ruleBook.opponent(color);
        output = 0;
        _ref4 = board.pieces()[color];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          defendingPiece = _ref4[_i];
          _ref5 = board.pieces()[opponent];
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            assaultingPiece = _ref5[_j];
            if (_ref6 = defendingPiece.position, __indexOf.call(this.ruleBook.availableMoves(assaultingPiece, board), _ref6) >= 0) {
              if (assaultingPiece.value < defendingPiece.value) {
                output += defendingPiece.value;
              } else {
                tempBoard = this.board.boardDup();
                tempBoard.forceMove(assaultingPiece.position, defendingPiece.position);
                assualtingPieceClone = tempBoard.pos(assaultingPiece.position);
                if (_ref7 = assaultingPieceClone.position, __indexOf.call(this.ruleBook.playerValidMoves(color, null, tempBoard), _ref7) < 0) {
                  output += defendingPiece.value;
                }
              }
            }
          }
        }
        return output;
      };

      AIPlayer.prototype.moveChoice = function(board1, level) {
        var board, counterMove, currentCounter, currentCounterMove, currentCounterValue, currentMove, currentMoveValue, move, opponentScore, tempBoard, tempMasterBoard, _i, _j, _len, _len1, _ref4, _ref5;
        board = board1 || this.ruleBook.board;
        level || (level = this.level);
        currentMove = [];
        currentMoveValue = 10000;
        currentCounterValue = -10000;
        _ref4 = this.ruleBook.playerValidMoves(this.color, true, board);
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          move = _ref4[_i];
          tempMasterBoard = board.boardDup();
          tempMasterBoard.forceMove.apply(tempMasterBoard, move);
          currentCounter = [];
          currentCounterValue = -10000;
          _ref5 = this.ruleBook.playerValidMoves(this.ruleBook.opponent(this.color), true, tempMasterBoard);
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            counterMove = _ref5[_j];
            tempBoard = tempMasterBoard.boardDup();
            tempBoard.forceMove.apply(tempBoard, counterMove);
            if (String(counterMove) === String([[8, 8], [8, 7]])) {
              debugger;
            }
            if (level <= 1) {
              opponentScore = this.scoreBoard(this.ruleBook.opponent(this.color), tempBoard);
            } else {
              opponentScore = this.moveChoice(tempBoard, level - 1)[1];
            }
            if (opponentScore > currentCounterValue) {
              currentCounterValue = opponentScore;
              currentCounterMove = counterMove;
              if (currentCounterValue > currentMoveValue) {
                break;
              }
            }
          }
          if (currentCounterValue <= currentMoveValue) {
            currentMove = move;
            currentMoveValue = currentCounterValue;
          }
        }
        if (board1) {
          return [currentMove, currentMoveValue];
        } else {
          return currentMove;
        }
      };

      return AIPlayer;

    })(Player);

    Chess.Game = Game = (function() {
      function Game(player1, player2, ruleBook) {
        this.ruleBook = new ruleBook;
        this.board = this.ruleBook.board;
        this.player1 = new player1('white', this.ruleBook);
        this.player2 = new player2('black', this.ruleBook);
        this.current_player = this.player1;
      }

      Game.prototype.playTurn = function(move) {
        var piece, validMovesString, _ref4;
        piece = this.ruleBook.board.pos(move[0]);
        if (piece) {
          validMovesString = piece.validMoves().map(function(el) {
            return el.toString();
          });
        }
        if (piece && (_ref4 = move[1].toString(), __indexOf.call(validMovesString, _ref4) >= 0)) {
          if (this.current_player === this.player1) {
            this.current_player = this.player2;
          } else {
            this.current_player = this.player1;
          }
          return this.board.pos(move[0]).forceMove(move[1]);
        } else {
          return alert('invalid move');
        }
      };

      return Game;

    })();

    return Chess;

  })();

}).call(this);
